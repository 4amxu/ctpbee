.. _函数:

函数
======================

交易函数
-----------
1, 发单函数---> send_order
    基于ctpbee的设计，让一切都变得自由和简单～
    没错发单也继承了此特性
    ctpbe提供了两种发单方式，核心对象发单直接发单和全局代理发单，以下是两种方式的简单介绍

    + 通过核心对象发单

        通过调用核心CtpBee的send_order接口来进行发单

        - 函数参数签名
            CtpBee.send_order()

        - 简单使用
            app.send_order(req)

        - 解释
            直接拿到核心app进行下单,接受参数为OrderReques, ctpbee提供了helper让你可以快速构建请求



    + 全局代理发单
        通过context的代理对象进行发单, 快速调度使用CtpBee使用接口，这个代理是可以全局进行访问的
        - 简单使用::

            from ctpbee import send_order
            send_order(order_req)

        - 函数签名
            def send_order(order_req: OrderRequest, app_name: str = "current_app") -> str:

        - 解释
            调用CtpBee对象进行发单, 当不指定account_name时候,默认调用current_app进行下单
            param: order_req  OrderRequest 发单请求
            param: app_name 字符串  CtpBee的第一个参数,默认为current_app，也就是当前最近推入栈中的对象



- 撤单函数::

    def cancle_order(cancle_req: CancelRequest, account_name: str = "current_app") -> None:
        """
            撤单, 当不指定account_name时候,默认调用current_app进行撤单
            param: cancle_req  OrderRequest 撤单请求
            param: account_name 字符串  CtpBee的第一个参数
        """
        ...

当前对象::

    def current_app() -> CtpBee:
        """
            返回栈顶的CtpBee对象
        """
        ...

切换对象::

    def switch_app(name:Text) -> None:
        """
            将名字为name的CtpBee的对象切换到栈顶
            param  : name 字符串 Ctpbee的第一个参数
            return : None
        """
        ...

获得对象::

    def get_app(name: Text) -> CtpBee:
        """
            用途: 根据app的名字查找CtpBee对象
            param  : name 字符串 CtpBee的第一个参数
            return : CtpBee对象/None
        """
        ...

查询持仓::

    def query_position(name: Text="current_app"):
        """
            调用Ctpbee对象进行查询持仓操作
            name 为CtpBee的第一个参数,默认为CtpBee
        """
        ...

查询账户::

    def query_account(name: Text="current_app"):
        """
           调用Ctpbee对象进行查询账户操作
           name 为CtpBee的第一个参数
        """

行情函数
-----------
订阅行情::

    def subscribe(symbol):
        """
            param  : symbol 字符串 订阅的代码
            return : None
        """
        通过symbol进行订阅函数




校验数据是否合法::

    def auth_time(data_time: time) -> bool:
        """
            校验时间tick或者bar的时间合不合法
            for example:
                data_time = tick.datetime.time()
        """
        if not isinstance(data_time, time):
            raise TypeError("参数类型错误, 期望为datatime.time}")
        DAY_START = time(9, 0)  # 日盘启动和停止时间
        DAY_END = time(15, 0)
        NIGHT_START = time(21, 0)  # 夜盘启动和停止时间
        NIGHT_END = time(2, 30)
        if data_time <= DAY_END and data_time >= DAY_START:
            return True
        if data_time >= NIGHT_START:
            return True
        if data_time <= NIGHT_END:
            return True
        return False




ctpbee内置快速为你构建各类请求的函数， 这些函数都被包括在helper助手里面::

    from ctpbee import helper




以下是各种方法， 出于考虑到数据的来源不同，内置了两种方式::

    # helper.generate_order_req_by_var::
    函数签名: symbol: str, exchange: Exchange, direction: Direction, offset: Offset, type: OrderType, volume, price
    函数返回: OrderRequest
    函数用途: 通过传入常量来构建OrderRequest
    for example：


    # helper.generate_order_req_by_str::
    函数签名: symbol: str, exchange: Exchange, direction: Direction, offset: Offset, type: OrderType, volume, price
    函数返回: OrderRequest
    函数用途: 通过传入字符串来构建OrderRequest, 可以大小写(除symbol,volume, price外)
